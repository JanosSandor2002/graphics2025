==== Camera.c ====
#include "Camera.h"
#include <math.h>
#include <GL/glu.h>  // Hibajavítás: szükséges a gluLookAt használatához

#define DEG2RAD(x) ((x)*3.14159265f/180.0f)

void Camera_Init(Camera* cam, float x, float y, float z) {
    cam->posX = x;
    cam->posY = y;
    cam->posZ = z;
    cam->yaw = -90.0f;
    cam->pitch = 0.0f;
}

void Camera_Move(Camera* cam, float forward, float right, float up) {
    float radYaw = DEG2RAD(cam->yaw);
    float radPitch = DEG2RAD(cam->pitch);

    cam->posX += forward * cosf(radYaw);
    cam->posZ += forward * sinf(radYaw);

    cam->posX += right * cosf(radYaw + 3.14159265f / 2);
    cam->posZ += right * sinf(radYaw + 3.14159265f / 2);

    cam->posY += up;
}

void Camera_Rotate(Camera* cam, float deltaYaw, float deltaPitch) {
    cam->yaw += deltaYaw;
    cam->pitch += deltaPitch;

    if (cam->pitch > 89.0f) cam->pitch = 89.0f;
    if (cam->pitch < -89.0f) cam->pitch = -89.0f;
}

void Camera_ApplyView(const Camera* cam) {
    float radYaw = DEG2RAD(cam->yaw);
    float radPitch = DEG2RAD(cam->pitch);

    float dirX = cosf(radYaw) * cosf(radPitch);
    float dirY = sinf(radPitch);
    float dirZ = sinf(radYaw) * cosf(radPitch);

    gluLookAt(
        cam->posX, cam->posY, cam->posZ,
        cam->posX + dirX, cam->posY + dirY, cam->posZ + dirZ,
        0.0f, 1.0f, 0.0f
    );
}


==== Fog.c ====
#include "Fog.h"
#include <GL/gl.h>

void init_fog() {
    GLfloat fogColor[] = {0.7f, 0.7f, 0.7f, 1.0f};

    glEnable(GL_FOG);
    glFogi(GL_FOG_MODE, GL_EXP2);
    glFogfv(GL_FOG_COLOR, fogColor);
    glFogf(GL_FOG_DENSITY, 0.08f);
    glHint(GL_FOG_HINT, GL_NICEST);
}


==== main.c ====
#define SDL_MAIN_HANDLED
#include <SDL2/SDL.h>
#include <SDL2/SDL_opengl.h>
#include <SOIL/SOIL.h>
#include <stdio.h>
#include <math.h>
#include "Camera.h"
#include "Model.h"
#include "Fog.h"

int windowWidth = 800;
int windowHeight = 600;

SDL_Window* window = NULL;
SDL_GLContext glContext;

Camera camera;
Model* glass = NULL;
Model* button = NULL;

GLuint glassTexture = 0;
GLuint helpTexture = 0;

int keyStates[SDL_NUM_SCANCODES] = {0};
int mouseLeftDown = 0;
int lastMouseX, lastMouseY;
int showHelp = 0;
float glassAlpha = 0.3f;
int buttonPressed = 0;

void handleKeys() {
    float speed = 0.1f;
    if (keyStates[SDL_SCANCODE_W]) Camera_Move(&camera, speed, 0, 0);
    if (keyStates[SDL_SCANCODE_S]) Camera_Move(&camera, -speed, 0, 0);
    if (keyStates[SDL_SCANCODE_A]) Camera_Move(&camera, 0, -speed, 0);
    if (keyStates[SDL_SCANCODE_D]) Camera_Move(&camera, 0, speed, 0);
    if (keyStates[SDL_SCANCODE_SPACE]) Camera_Move(&camera, 0, 0, speed);
    if (keyStates[SDL_SCANCODE_C]) Camera_Move(&camera, 0, 0, -speed);

    if (camera.posY < 1.0f) camera.posY = 1.0f;
}

void checkButtonPress() {
    float dx = camera.posX - 0.0f;
    float dy = camera.posY - 0.0f;
    float dz = camera.posZ - 0.0f;
    float distance = sqrtf(dx*dx + dy*dy + dz*dz);
    if (!buttonPressed && distance < 1.0f) {
        buttonPressed = 1;
        printf("Gomb lenyomva!\n");
    }
}

void display() {
    glClearColor(0.0f, 0.07f, 0.27f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();

    Camera_ApplyView(&camera);

    // Átlátszó objektum
    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, glassTexture);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glDepthMask(GL_FALSE);

    float minY = get_model_min_y(glass);
    glPushMatrix();
    glTranslatef(0.0f, -minY * 11.0f, 0.0f);
    glScalef(11.0f, 11.0f, 11.0f);
    glColor4f(1.0f, 1.0f, 1.0f, glassAlpha);
    draw_model(glass);
    glPopMatrix();

    glDepthMask(GL_TRUE);
    glDisable(GL_BLEND);
    glDisable(GL_TEXTURE_2D);
    glDisable(GL_CULL_FACE);

    // Gomb kirajzolása
    glPushMatrix();
    glTranslatef(0.0f, 0.0f, 0.0f);
    glScalef(2.0f, 2.0f, 2.0f);
    glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
    draw_model(button);
    glPopMatrix();

    // Help overlay
    if (showHelp && helpTexture != 0) {
        glMatrixMode(GL_PROJECTION);
        glPushMatrix();
        glLoadIdentity();
        glOrtho(0, windowWidth, windowHeight, 0, -1, 1);

        glMatrixMode(GL_MODELVIEW);
        glPushMatrix();
        glLoadIdentity();

        glDisable(GL_DEPTH_TEST);
        glEnable(GL_TEXTURE_2D);
        glBindTexture(GL_TEXTURE_2D, helpTexture);
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

        glColor4f(1, 1, 1, glassAlpha);
        glBegin(GL_QUADS);
        glTexCoord2f(0, 0); glVertex2f(0, 0);
        glTexCoord2f(1, 0); glVertex2f(windowWidth, 0);
        glTexCoord2f(1, 1); glVertex2f(windowWidth, windowHeight);
        glTexCoord2f(0, 1); glVertex2f(0, windowHeight);
        glEnd();

        glDisable(GL_BLEND);
        glDisable(GL_TEXTURE_2D);
        glEnable(GL_DEPTH_TEST);

        glPopMatrix();
        glMatrixMode(GL_PROJECTION);
        glPopMatrix();
        glMatrixMode(GL_MODELVIEW);
    }

    SDL_GL_SwapWindow(window);
}

void processEvents(SDL_Event* e) {
    while (SDL_PollEvent(e)) {
        switch (e->type) {
            case SDL_QUIT:
                exit(0);
                break;
            case SDL_KEYDOWN:
                keyStates[e->key.keysym.scancode] = 1;
                if (e->key.keysym.sym == SDLK_F1) showHelp = !showHelp;
                if (e->key.keysym.sym == SDLK_PLUS || e->key.keysym.sym == SDLK_KP_PLUS) {
                    glassAlpha += 0.05f;
                    if (glassAlpha > 1.0f) glassAlpha = 1.0f;
                } else if (e->key.keysym.sym == SDLK_MINUS || e->key.keysym.sym == SDLK_KP_MINUS) {
                    glassAlpha -= 0.05f;
                    if (glassAlpha < 0.05f) glassAlpha = 0.05f;
                }
                break;
            case SDL_KEYUP:
                keyStates[e->key.keysym.scancode] = 0;
                break;
            case SDL_MOUSEBUTTONDOWN:
                if (e->button.button == SDL_BUTTON_LEFT) {
                    mouseLeftDown = 1;
                    lastMouseX = e->button.x;
                    lastMouseY = e->button.y;
                }
                break;
            case SDL_MOUSEBUTTONUP:
                if (e->button.button == SDL_BUTTON_LEFT) {
                    mouseLeftDown = 0;
                }
                break;
            case SDL_MOUSEMOTION:
                if (mouseLeftDown) {
                    int dx = e->motion.x - lastMouseX;
                    int dy = e->motion.y - lastMouseY;
                    Camera_Rotate(&camera, dx * 0.2f, -dy * 0.2f);
                    lastMouseX = e->motion.x;
                    lastMouseY = e->motion.y;
                }
                break;
        }
    }
}

int main(int argc, char* argv[]) {
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        printf("SDL init hiba: %s\n", SDL_GetError());
        return 1;
    }

    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 1);
    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);

    window = SDL_CreateWindow("SDL + OpenGL Kamera", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
                              windowWidth, windowHeight, SDL_WINDOW_OPENGL | SDL_WINDOW_SHOWN);
    if (!window) {
        printf("Ablak letrehozasi hiba: %s\n", SDL_GetError());
        SDL_Quit();
        return 1;
    }

    glContext = SDL_GL_CreateContext(window);
    if (!glContext) {
        printf("GL context hiba: %s\n", SDL_GetError());
        SDL_DestroyWindow(window);
        SDL_Quit();
        return 1;
    }

    glEnable(GL_DEPTH_TEST);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    init_fog();

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(60.0f, (float)windowWidth / (float)windowHeight, 0.1f, 100.0f);
    glMatrixMode(GL_MODELVIEW);

    Camera_Init(&camera, 1.0f, 5.0f, 30.0f);

    glass = load_model("assets/models/glass.obj");
    button = load_model("assets/models/button.obj");
    if (!glass || !button) {
        printf("Modell betoltesi hiba\n");
        return 1;
    }

    glassTexture = SOIL_load_OGL_texture("assets/textures/glass.png", SOIL_LOAD_AUTO, SOIL_CREATE_NEW_ID, SOIL_FLAG_INVERT_Y);
    helpTexture = SOIL_load_OGL_texture("assets/textures/help.png", SOIL_LOAD_AUTO, SOIL_CREATE_NEW_ID, SOIL_FLAG_INVERT_Y);

    SDL_Event e;
    while (1) {
        processEvents(&e);
        handleKeys();
        checkButtonPress();
        display();
        SDL_Delay(16);  // ~60 FPS
    }

    free_model(glass);
    free_model(button);
    SDL_GL_DeleteContext(glContext);
    SDL_DestroyWindow(window);
    SDL_Quit();
    return 0;
}


==== Model.c ====
#include "Model.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <GL/gl.h>  // OpenGL fejlécek (győződj meg róla, hogy elérhető)

Model* load_model(const char* filename) {
    FILE* file = fopen(filename, "r");
    if (!file) {
        perror("Could not open OBJ file");
        return NULL;
    }

    Model* model = calloc(1, sizeof(Model));

    size_t vertex_cap = 1024;
    size_t texcoord_cap = 1024;
    size_t normal_cap = 1024;
    size_t face_cap = 1024;

    model->vertices = malloc(vertex_cap * sizeof(Vertex));
    model->texcoords = malloc(texcoord_cap * sizeof(TexCoord));
    model->normals = malloc(normal_cap * sizeof(Normal));
    model->faces = malloc(face_cap * sizeof(Face));

    char line[256];

    while (fgets(line, sizeof(line), file)) {
        if (strncmp(line, "v ", 2) == 0) {
            if (model->vertex_count >= vertex_cap) {
                vertex_cap *= 2;
                model->vertices = realloc(model->vertices, vertex_cap * sizeof(Vertex));
            }
            sscanf(line + 2, "%f %f %f",
                &model->vertices[model->vertex_count].x,
                &model->vertices[model->vertex_count].y,
                &model->vertices[model->vertex_count].z);
            model->vertex_count++;
        } else if (strncmp(line, "vt ", 3) == 0) {
            if (model->texcoord_count >= texcoord_cap) {
                texcoord_cap *= 2;
                model->texcoords = realloc(model->texcoords, texcoord_cap * sizeof(TexCoord));
            }
            sscanf(line + 3, "%f %f",
                &model->texcoords[model->texcoord_count].u,
                &model->texcoords[model->texcoord_count].v);
            model->texcoord_count++;
        } else if (strncmp(line, "vn ", 3) == 0) {
            if (model->normal_count >= normal_cap) {
                normal_cap *= 2;
                model->normals = realloc(model->normals, normal_cap * sizeof(Normal));
            }
            sscanf(line + 3, "%f %f %f",
                &model->normals[model->normal_count].x,
                &model->normals[model->normal_count].y,
                &model->normals[model->normal_count].z);
            model->normal_count++;
        } else if (strncmp(line, "f ", 2) == 0) {
            if (model->face_count >= face_cap) {
                face_cap *= 2;
                model->faces = realloc(model->faces, face_cap * sizeof(Face));
            }

            Face* f = &model->faces[model->face_count];
            sscanf(line + 2, "%u/%u/%u %u/%u/%u %u/%u/%u",
                &f->v1, &f->vt1, &f->vn1,
                &f->v2, &f->vt2, &f->vn2,
                &f->v3, &f->vt3, &f->vn3);
            // Convert to zero-based indexing
            f->v1--; f->vt1--; f->vn1--;
            f->v2--; f->vt2--; f->vn2--;
            f->v3--; f->vt3--; f->vn3--;

            model->face_count++;
        }
    }

    fclose(file);
    return model;
}

void draw_model(const Model* model) {
    if (!model) return;

    glBegin(GL_TRIANGLES);
    for (unsigned int i = 0; i < model->face_count; i++) {
        Face* f = &model->faces[i];

        if (model->normal_count > 0) {
            glNormal3f(
                model->normals[f->vn1].x,
                model->normals[f->vn1].y,
                model->normals[f->vn1].z);
        }
        if (model->texcoord_count > 0) {
            glTexCoord2f(
                model->texcoords[f->vt1].u,
                model->texcoords[f->vt1].v);
        }
        glVertex3f(
            model->vertices[f->v1].x,
            model->vertices[f->v1].y,
            model->vertices[f->v1].z);

        if (model->normal_count > 0) {
            glNormal3f(
                model->normals[f->vn2].x,
                model->normals[f->vn2].y,
                model->normals[f->vn2].z);
        }
        if (model->texcoord_count > 0) {
            glTexCoord2f(
                model->texcoords[f->vt2].u,
                model->texcoords[f->vt2].v);
        }
        glVertex3f(
            model->vertices[f->v2].x,
            model->vertices[f->v2].y,
            model->vertices[f->v2].z);

        if (model->normal_count > 0) {
            glNormal3f(
                model->normals[f->vn3].x,
                model->normals[f->vn3].y,
                model->normals[f->vn3].z);
        }
        if (model->texcoord_count > 0) {
            glTexCoord2f(
                model->texcoords[f->vt3].u,
                model->texcoords[f->vt3].v);
        }
        glVertex3f(
            model->vertices[f->v3].x,
            model->vertices[f->v3].y,
            model->vertices[f->v3].z);
    }
    glEnd();
}

void free_model(Model* model) {
    if (!model) return;

    free(model->vertices);
    free(model->texcoords);
    free(model->normals);
    free(model->faces);
    free(model);
}
float get_model_min_y(const Model* model) {
    if (!model || model->vertex_count == 0) return 0.0f;

    float minY = model->vertices[0].y;
    for (unsigned int i = 1; i < model->vertex_count; i++) {
        if (model->vertices[i].y < minY) {
            minY = model->vertices[i].y;
        }
    }
    return minY;
}



